package lk.epicgreen.erp.accounting.entity;


import lk.epicgreen.erp.admin.entity.User;
import lombok.*;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.PositiveOrZero;
import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * TrialBalance entity
 * Represents trial balance snapshots for financial periods
 * 
 * @author Epic Green Development Team
 * @version 1.0
 */
@Entity
@Table(name = "trial_balance",
    uniqueConstraints = @UniqueConstraint(name = "uk_period_account", columnNames = {"period_id", "account_id"}),
    indexes = {
        @Index(name = "idx_period_id", columnList = "period_id"),
        @Index(name = "idx_account_id", columnList = "account_id")
    })
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TrialBalance {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * Financial period
     */
    @NotNull(message = "Period is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "period_id", nullable = false, foreignKey = @ForeignKey(name = "fk_trial_balance_period"))
    private FinancialPeriod period;
    
    /**
     * Account
     */
    @NotNull(message = "Account is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "account_id", nullable = false, foreignKey = @ForeignKey(name = "fk_trial_balance_account"))
    private ChartOfAccounts account;


    /**
     * Opening debit balance
     */

    
    /**
     * Opening credit balance
     */


    @PositiveOrZero(message = "Opening credit must be positive or zero")
    @Column(name = "opening_credit", precision = 15, scale = 2)
    private BigDecimal openingCredit;
    
    /**
     * Period debit (total debits in period)
     */
    @PositiveOrZero(message = "Period debit must be positive or zero")
    @Column(name = "period_debit", precision = 15, scale = 2)
    private BigDecimal periodDebit;

    @PositiveOrZero(message = "Opening debit must be positive or zero")
    @Column(name = "opening_debit", precision = 15, scale = 2)
    private BigDecimal openingDebit;
    /**
     * Period credit (total credits in period)
     */
    @PositiveOrZero(message = "Period credit must be positive or zero")
    @Column(name = "period_credit", precision = 15, scale = 2)
    private BigDecimal periodCredit;
    
    /**
     * Closing debit balance
     */
    @PositiveOrZero(message = "Closing debit must be positive or zero")
    @Column(name = "closing_debit", precision = 15, scale = 2)
    private BigDecimal closingDebit;
    
    /**
     * Closing credit balance
     */
    @PositiveOrZero(message = "Closing credit must be positive or zero")
    @Column(name = "closing_credit", precision = 15, scale = 2)
    private BigDecimal closingCredit;
    
    /**
     * Generated timestamp
     */
    @Column(name = "generated_at")
    private LocalDateTime generatedAt;
    
    /**
     * Generated by (user)
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "generated_by", foreignKey = @ForeignKey(name = "fk_trial_balance_generated_by"))
    private User generatedBy;
    
    /**
     * Get opening balance (net)
     */
    @Transient
    public BigDecimal getOpeningBalance() {
        BigDecimal debit = openingDebit != null ? openingDebit : BigDecimal.ZERO;
        BigDecimal credit = openingCredit != null ? openingCredit : BigDecimal.ZERO;
        return debit.subtract(credit);
    }
    
    /**
     * Get period movement (net)
     */
    @Transient
    public BigDecimal getPeriodMovement() {
        BigDecimal debit = periodDebit != null ? periodDebit : BigDecimal.ZERO;
        BigDecimal credit = periodCredit != null ? periodCredit : BigDecimal.ZERO;
        return debit.subtract(credit);
    }
    
    /**
     * Get closing balance (net)
     */
    @Transient
    public BigDecimal getClosingBalance() {
        BigDecimal debit = closingDebit != null ? closingDebit : BigDecimal.ZERO;
        BigDecimal credit = closingCredit != null ? closingCredit : BigDecimal.ZERO;
        return debit.subtract(credit);
    }
    
    /**
     * Check if opening is debit
     */
    @Transient
    public boolean isOpeningDebit() {
        return getOpeningBalance().compareTo(BigDecimal.ZERO) >= 0;
    }
    
    /**
     * Check if opening is credit
     */
    @Transient
    public boolean isOpeningCredit() {
        return getOpeningBalance().compareTo(BigDecimal.ZERO) < 0;
    }
    
    /**
     * Check if closing is debit
     */
    @Transient
    public boolean isClosingDebit() {
        return getClosingBalance().compareTo(BigDecimal.ZERO) >= 0;
    }
    
    /**
     * Check if closing is credit
     */
    @Transient
    public boolean isClosingCredit() {
        return getClosingBalance().compareTo(BigDecimal.ZERO) < 0;
    }
    
    /**
     * Calculate closing balances
     */
    @Transient
    public void calculateClosingBalances() {
        BigDecimal openingDr = openingDebit != null ? openingDebit : BigDecimal.ZERO;
        BigDecimal openingCr = openingCredit != null ? openingCredit : BigDecimal.ZERO;
        BigDecimal periodDr = periodDebit != null ? periodDebit : BigDecimal.ZERO;
        BigDecimal periodCr = periodCredit != null ? periodCredit : BigDecimal.ZERO;
        
        // Calculate net closing
        BigDecimal totalDebit = openingDr.add(periodDr);
        BigDecimal totalCredit = openingCr.add(periodCr);
        
        BigDecimal netBalance = totalDebit.subtract(totalCredit);
        
        if (netBalance.compareTo(BigDecimal.ZERO) >= 0) {
            // Debit balance
            closingDebit = netBalance;
            closingCredit = BigDecimal.ZERO;
        } else {
            // Credit balance
            closingDebit = BigDecimal.ZERO;
            closingCredit = netBalance.abs();
        }
    }
    
    @PrePersist
    @PreUpdate
    protected void onSave() {
        if (openingDebit == null) {
            openingDebit = BigDecimal.ZERO;
        }
        if (openingCredit == null) {
            openingCredit = BigDecimal.ZERO;
        }
        if (periodDebit == null) {
            periodDebit = BigDecimal.ZERO;
        }
        if (periodCredit == null) {
            periodCredit = BigDecimal.ZERO;
        }
        if (generatedAt == null) {
            generatedAt = LocalDateTime.now();
        }
        
        calculateClosingBalances();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof TrialBalance)) return false;
        TrialBalance that = (TrialBalance) o;
        return id != null && id.equals(that.getId());
    }
    
    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
